#!/usr/bin/python3

# Script: Ops 401 Class 33 script
# Author: Paul Stroud
# Date of latest revision: 06/01/23
# Purpose: Signature-based Malware Detection Part 3 of 3
# Resources used: google, stackoverflow, github demo, chatgpt
#                 https://github.com/eduardxyz/virustotal-search/blob/master/virustotal-search.py  

# MAIN REQS:
# Add to your malware detection script features to:
#   Successfully connect to the VirusTotal API
#   Automatically compare your target file’s md5 hash with the hash values of entries on VirusTotal API
#   Print to the screen the number of positives detected and total files scanned

import platform     # to get OS name
import os           # for os.walk() recursive directory list
import hashlib      # to calc hashes
import datetime     # to get date/time
import math         # for math functions (floor, log, pow)
import time         # for time() and sleep()
import sys          # for sys.exit
import requests     # to parse HTTP requests


### FUNCTIONS ####

# runs a timer and prints the seconds/countdown
# the number is updated in place
def timeout(timer):
    wspace1 = 0     # prev digit counter; init the var for use in the loop
    for i in range(timer, 0, -1):
       print(i, end='', flush=True)     # "flush=True" to display immediately (could hang otherwise)
       wspace = len(str(i)) # number of digits in i
       # if fewer digits than last loop, print an extra space
       if wspace < wspace1: print(' \b', end='', flush=True)    
       time.sleep(1)
       print('\b' * wspace, end='', flush=True) # erase the number
       wspace1 = wspace     # save value for the next loop


def table_fmt(strlist, width):
    lw = len(width)
    if (len(strlist) != lw + 1):
      raise Exception("<width> must have 1 fewer elements than <strlist>")
    output = ""
    for i in range(0, lw):
       output += f"{strlist[0]:<{width[0]}}"
    output += strlist(lw)


# validate the length of the API key
# based on checkkey() function from virustotal-search.py
def check_api_key(ckey):
	try:
		if len(ckey) == 64: return 0
		else: return 1
	except Exception as Error:
          print(Error)
          sys.exit()


last_api_time = 0
api_timeout = 15
# VirusTotal API request to search for a file checksum
# based on VT_Request() function from virustotal-search.py
def malware_check(api_key, hash):
    global last_api_time, api_timeout                   # grab global vars
    if time.time() - last_api_time < api_timeout:       # if last call less than N sec ago, start the cool-off timer
      print("API timeout for VirusTotal: ", end="")
      timeout(15)
      print(f"\r{' '*80}\r", end='')                    # erase last line

    # API call via HTTP request
    url = requests.get("https://www.virustotal.com/vtapi/v2/file/report", 
                    params={"apikey": api_key, "resource": hash})
    last_api_time = time.time()                         # update the API time tracker

    json_response = url.json()                          # parse the JSON
    response = int(json_response.get("response_code"))  # extract the numeric response code

    if response == 0: return 2, "NOT FOUND"             # hash not found in VT database
    elif response == 1:                                 # if valid response
      positives = int(json_response.get("positives"))   # how many AVs flagged it?
      if positives >= 3:
        return 1, "DANGER ☠ ⚠ ☠"                      # multiple red flags
      else: return 0, "SAFE ✓"                          # probably safe? 2 or fewer flags
    else: return -1, "<unknown>"                        # any other response


blocksize = 65536       # how many bytes to read at a time
# calc a SHA1 hash for the file
def sha1_chksum(fname):
    shaka = hashlib.sha1()          # holds the sha1 hash
    with open(fname, 'rb') as file: # process the file
         slice = 0                  # initialize the var; holds chunks of the file
         while slice != b'':        # repeat until the whole file's been processed
              slice = file.read(blocksize)  # read a block
              shaka.update(slice)           # recalculate the hash
    return shaka.hexdigest()        # return hash as a hex string

fsize_str = ("B", "KB", "MB", "GB", "TB")   # global tuple to hold file size units
# convert integer filesize in bytes to a human-readable format
def fmt_fsize(fsize):      
    if fsize == 0: return "0 B"     # if zero, return "0 B" to avoid an error

    unit = int(math.floor(math.log(fsize, 1024)))       # calc the power of 1024 that is closest to fsize
    adj_size = round(fsize / math.pow(1024, unit), 2)   # calc adjusted size in KB, MB, etc.
    if adj_size % 1 == 0: adj_size = int(adj_size)

    return f"{adj_size} {fsize_str[unit]}"              # return the string "N xB": for example, "15.26 MB"

   

#### MAIN ####

# validate the API key arg

if len(sys.argv) < 2:
  print("Error: Please provide the VirusTotal API key as the script argument.")
  sys.exit()

api_key = sys.argv[1]

if (check_api_key(api_key)):
  print("Error: Invalid API key length. Please provide a 64-character key.")
  sys.exit()
     

os_name = platform.system()   # get the OS name
if not (os_name == "Linux" or os_name == "Windows"):
    print("ERROR: Unknown OS. Exiting...")  # doesn't like apples
print(f"OS = {os_name}")


dir = input("Enter the full dir path to search (current dir if empty) : ")
#dir = "/home/user/TEST"
dir = dir if dir != '' else os.getcwd() # if no input, use PWD from the OS


total_files = 0     # all files in the dir/subdirs
mal_files = 0       # detected malware counter

print(f"\n[ Contents of {dir}: ]")

hash_array = []     # 2D array to hold checksums and other file metadata
tab = "  "          # constant for tabbing out text
dtab = ""           # indent for dir names
ftab = tab          # indent for file names
for rootdir, subdirs, files in os.walk(dir):    # recursively parse the dir
    total_files += len(files)                   # count all files

    print(f"{dtab}{rootdir}/")                  # print the dir name
    if not files: print(ftab + "<no files>")    # if dir is empty
    else:                                       # if there are files in this dir
        for i in files:
            print(f"{ftab}- {i}")                                                   # print file names in a list
            full_path = f'{rootdir}/{i}'                                            # add extra '/' for the full file path
            cur_time = datetime.datetime.now().strftime("%Y%m%d %H:%M:%S")          # format date/time
            filesize = os.path.getsize(full_path)                                   # get file size
            hash = sha1_chksum(full_path)                                           # calc SHA1 hash
            virus = malware_check(api_key, hash)                                    # send hash to VirusTotal
            if virus[0] == 1: mal_files += 1                                        # count malware
            hash_array.append([i, hash, virus[1], cur_time, fmt_fsize(filesize), full_path])  # add all data to the array
    dtab += tab     # increase dir indent
    ftab += tab     # increase file indent


# test_hash = "77fed3357bf22385a18f5ab4008753cba324cce3"
# hash_array.append(["malware.test", test_hash, malware_check(api_key, test_hash)[1], cur_time, "200 TB", "/some/where/else/malware.test"])
# mal_files += 1


### REQ: Print the variable to the screen along with a timestamp, 
###      file name, file size, and complete (not symbolic) file path.
columns = [ "FILE NAME", "SHA1 HASH", "MALWARE", "DATE/TIME", "FILE SIZE", "FILE LOCATION" ]
column_width = []   # holds column widths for output formatting
for i in range(len(columns)):
   # calc the correct width for the largest text in the column + 3 extra chars for whitespace
   column_width.append(max(max(len(row[i]) for row in hash_array), len(columns[i]))+3)

# pre-format output with proper spacing for column names
output = f"{columns[0]:<{column_width[0]}}" \
         f"{columns[1]:<{column_width[1]}}" \
         f"{columns[2]:<{column_width[2]}}" \
         f"{columns[3]:<{column_width[3]}}" \
         f"{columns[4]:<{column_width[4]}}" \
         f"{columns[5]}"
print(f'\n{output}')

for i in range(len(hash_array)):    # iterate over the array
   # pre-format output with proper spacing for each column
   output = f"{hash_array[i][0]:<{column_width[0]}}" \
            f"{hash_array[i][1]:<{column_width[1]}}" \
            f"{hash_array[i][2]:<{column_width[2]}}" \
            f"{hash_array[i][3]:<{column_width[3]}}" \
            f"{hash_array[i][4]:<{column_width[4]}}" \
            f"{hash_array[i][5]}"
   print(output)

# more numbers
print(f"\n[ SCRIPT STATS for {dir}]")
print(f'  Potential malware:\t{mal_files}')
print(f'  Total files scanned:\t{total_files}')

# le end